<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archers Chess vs AI - v1.2</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background: #f0d9b5; color: #333; margin: 10px; }
        canvas { border: 4px solid #8b4513; cursor: pointer; background: #deb887; box-shadow: 0 0 15px rgba(0,0,0,0.5); }
        h1 { color: #8b0000; margin: 10px; }
        #status { font-size: 22px; font-weight: bold; margin: 15px; color: #444; }
        select, button { font-size: 18px; padding: 8px 16px; margin: 5px; border-radius: 6px; cursor: pointer; }
        button { background: #8b4513; color: white; border: none; }
        button:hover { background: #a0522d; }
        details { margin: 20px auto; max-width: 800px; text-align: left; }
        summary { font-size: 20px; cursor: pointer; color: #8b0000; }
        a { color: #8b0000; text-decoration: underline; }
        .highlight { fill: rgba(0,255,0,0.3); stroke: rgba(0,255,0,0.6); stroke-width: 3; }
    </style>
</head>
<body>
    <h1>üèπ Archers Chess v1.2 - Play White vs AI</h1>
    <p>Full rules + Archer + castling. Choose AI level:</p>
    <div>
        <label>AI Difficulty: </label>
        <select id="aiLevel">
            <option value="easy">Easy</option>
            <option value="normal" selected>Normal</option>
            <option value="hard">Hard</option>
        </select>
        <button onclick="init()">New Game</button>
    </div>
    <div id="status">Your Turn (White)</div>
    <canvas id="board" width="600" height="480"></canvas>
    <p>Files: ‚ÄìA A B C D E F G H H+</p>

    <details>
        <summary>üìú Game Rules & Archer Movement</summary>
        <p>Archers Chess is played on a 10√ó8 board with standard chess rules + 2 Archers per side.</p>
        <p><strong>The Archer</strong> moves in two phases:</p>
        <ul>
            <li><strong>Outward</strong>: exactly 3 squares straight or diagonal (straight: no jump; diagonal: can jump).</li>
            <li><strong>Return</strong>: exactly 1 square back at 45¬∞ diagonal (choose left or right).</li>
            <li>Capture only on the final square.</li>
        </ul>
        <p>Castling works as in standard chess (king + rook, path clear, not in check).</p>
        <p>Full official rules & declaration (PDF): <a href="Archers_Chess_Master_Rules_Appendices_Declaration_v1.0.pdf" target="_blank">Download PDF</a></p>
    </details>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const SQ = 60;
        const FILES = 10;
        const RANKS = 8;
        const statusEl = document.getElementById('status');

        let board = new Array(FILES * RANKS).fill(null);
        let selected = null;
        let turn = 'w';
        let gameOver = false;

        // Castling flags
        let whiteKingMoved = false;
        let blackKingMoved = false;
        let whiteRookLeftMoved = false;
        let whiteRookRightMoved = false;
        let blackRookLeftMoved = false;
        let blackRookRightMoved = false;

        const pieceSymbols = {
            'K':'‚ôî','Q':'‚ôï','R':'‚ôñ','B':'‚ôó','N':'‚ôò','P':'‚ôô','A':'üèπ',
            'k':'‚ôö','q':'‚ôõ','r':'‚ôú','b':'‚ôù','n':'‚ôû','p':'‚ôü','a':'üèπ'
        };

        const dirs = {
            rook: [[0,1],[0,-1],[1,0],[-1,0]],
            bishop: [[1,1],[1,-1],[-1,1],[-1,-1]],
            queen: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            king: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            knight: [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]]
        };

        function init() {
            board.fill(null);
            board[0*RANKS+0] = 'A'; board[1*RANKS+0] = 'R'; board[2*RANKS+0] = 'N';
            board[3*RANKS+0] = 'B'; board[4*RANKS+0] = 'Q'; board[5*RANKS+0] = 'K';
            board[6*RANKS+0] = 'B'; board[7*RANKS+0] = 'N'; board[8*RANKS+0] = 'R'; board[9*RANKS+0] = 'A';
            for(let f=0; f<FILES; f++) board[f*RANKS+1] = 'P';
            for(let f=0; f<FILES; f++) board[f*RANKS+6] = 'p';
            board[0*RANKS+7] = 'a'; board[1*RANKS+7] = 'r'; board[2*RANKS+7] = 'n';
            board[3*RANKS+7] = 'b'; board[4*RANKS+7] = 'q'; board[5*RANKS+7] = 'k';
            board[6*RANKS+7] = 'b'; board[7*RANKS+7] = 'n'; board[8*RANKS+7] = 'r'; board[9*RANKS+7] = 'a';

            selected = null;
            turn = 'w';
            gameOver = false;
            whiteKingMoved = false;
            blackKingMoved = false;
            whiteRookLeftMoved = false;
            whiteRookRightMoved = false;
            blackRookLeftMoved = false;
            blackRookRightMoved = false;
            statusEl.textContent = "Your Turn (White)";
            drawBoard();
        }

        function idx(f, r) { return f * RANKS + r; }
        function fileOf(sq) { return Math.floor(sq / RANKS); }
        function rankOf(sq) { return sq % RANKS; }
        function isOnBoard(f,r) { return f>=0 && f<FILES && r>=0 && r<RANKS; }
        function pieceAt(sq) { return board[sq]; }
        function isWhite(p) { return p && p === p.toUpperCase(); }
        function sameSide(p1,p2) { return p1 && p2 && isWhite(p1) === isWhite(p2); }

        function drawBoard() {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            for(let r=7; r>=0; r--) {
                for(let f=0; f<FILES; f++) {
                    let x = f * SQ;
                    let y = (7 - r) * SQ;
                    ctx.fillStyle = ((f + r) % 2 === 0) ? '#f0d9b5' : '#b58863';
                    ctx.fillRect(x, y, SQ, SQ);
                    let p = pieceAt(idx(f,r));
                    if (p) {
                        ctx.fillStyle = isWhite(p) ? '#fff' : '#000';
                        ctx.font = 'bold 48px serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(pieceSymbols[p], x + SQ/2, y + SQ/2 + 4);
                    }
                    if (selected === idx(f,r)) {
                        ctx.strokeStyle = '#ffeb3b';
                        ctx.lineWidth = 5;
                        ctx.strokeRect(x+4, y+4, SQ-8, SQ-8);
                    }
                }
            }
        }

        function isPathClear(startSq, endSq, dx, dy) {
            let f = fileOf(startSq) + dx, r = rankOf(startSq) + dy;
            while (f !== fileOf(endSq) || r !== rankOf(endSq)) {
                if (pieceAt(idx(f,r))) return false;
                f += dx; r += dy;
            }
            return true;
        }

        function isValidMove(startSq, endSq) {
            if (startSq === endSq) return false;
            let p = pieceAt(startSq);
            if (!p) return false;
            let tp = pieceAt(endSq);
            if (tp && sameSide(p, tp)) return false;

            let sf = fileOf(startSq), sr = rankOf(startSq);
            let ef = fileOf(endSq), er = rankOf(endSq);
            let dx = ef - sf, dy = er - sr;

            // Standard pawn, knight, king, sliding moves (unchanged)
            if (p.toUpperCase() === 'P') {
                let dir = isWhite(p) ? 1 : -1;
                if (dx === 0 && dy === dir && !tp) return true;
                if (dx === 0 && dy === 2*dir && sr === (isWhite(p)?1:6) && !tp && !pieceAt(idx(sf,sr+dir))) return true;
                if (Math.abs(dx)===1 && dy===dir && tp) return true;
                return false;
            }

            if (p.toUpperCase() === 'N') return dirs.knight.some(d => d[0]===dx && d[1]===dy);

            if (p.toUpperCase() === 'K') {
                // Normal king move
                if (Math.max(Math.abs(dx), Math.abs(dy)) <= 1) return true;

                // Castling
                if (!isWhite(p) ? blackKingMoved : whiteKingMoved) return false;
                if (Math.abs(dx) !== 2 || dy !== 0) return false;
                const rookFile = dx > 0 ? 9 : 0; // H+ or ‚ÄìA
                const rookSq = idx(rookFile, sr);
                const rook = pieceAt(rookSq);
                if (!rook || rook.toUpperCase() !== 'R') return false;
                if (isWhite(p) ? (dx > 0 ? whiteRookRightMoved : whiteRookLeftMoved) : (dx > 0 ? blackRookRightMoved : blackRookLeftMoved)) return false;
                // Path clear
                const step = dx > 0 ? 1 : -1;
                for (let i = sf + step; i !== rookFile; i += step) {
                    if (pieceAt(idx(i, sr))) return false;
                }
                return true;
            }

            if (p.toUpperCase() === 'A') {
                const outDirs = dirs.queen;
                for (let [odx, ody] of outDirs) {
                    if (odx===0 && ody===0) continue;
                    let f1 = sf + odx, r1 = sr + ody;
                    let f2 = f1 + odx, r2 = r1 + ody;
                    let f3 = f2 + odx, r3 = r2 + ody;
                    if (!isOnBoard(f3,r3)) continue;
                    if ((odx===0 || ody===0) && (pieceAt(idx(f1,r1)) || pieceAt(idx(f2,r2)) || pieceAt(idx(f3,r3)))) continue;
                    const back = [-odx, -ody];
                    const offsets = [[back[0] - ody, back[1] + odx], [back[0] + ody, back[1] - odx]];
                    for (let [ox, oy] of offsets) {
                        const len = Math.hypot(ox, oy);
                        if (len === 0) continue;
                        const sx = Math.round(ox / len), sy = Math.round(oy / len);
                        const ff = f3 + sx, rr = r3 + sy;
                        if (isOnBoard(ff,rr) && ff===ef && rr===er) return true;
                    }
                }
                return false;
            }

            let slides = p.toUpperCase() === 'R' ? dirs.rook :
                         p.toUpperCase() === 'B' ? dirs.bishop :
                         p.toUpperCase() === 'Q' ? dirs.queen : [];
            for (let [ddx, ddy] of slides) {
                if (ddx * dy === ddy * dx && Math.sign(ddx)===Math.sign(dx) && Math.sign(ddy)===Math.sign(dy)) {
                    return isPathClear(startSq, endSq, Math.sign(dx), Math.sign(dy));
                }
            }
            return false;
        }

        canvas.addEventListener('click', e => {
            if (gameOver || turn === 'b') return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const f = Math.floor(x / SQ);
            const r = 7 - Math.floor(y / SQ);
            if (!isOnBoard(f,r)) return;
            const sq = idx(f,r);

            if (selected === null) {
                const p = pieceAt(sq);
                if (p && isWhite(p)) {
                    selected = sq;
                    drawBoard();
                }
            } else {
                if (isValidMove(selected, sq)) {
                    board[sq] = pieceAt(selected);
                    board[selected] = null;
                    turn = turn === 'w' ? 'b' : 'w';
                    statusEl.textContent = turn === 'w' ? "Your Turn (White)" : "AI's Turn";
                    if (turn === 'b') {
                        statusEl.textContent = "AI Thinking...";
                        setTimeout(aiMove, 500);
                    }
                }
                selected = null;
                drawBoard();
            }
        });

        function aiMove() {
            const moves = [];
            for (let sq = 0; sq < board.length; sq++) {
                const p = pieceAt(sq);
                if (!p || isWhite(p)) continue;
                for (let t = 0; t < board.length; t++) {
                    if (isValidMove(sq, t)) moves.push({from: sq, to: t});
                }
            }
            if (moves.length > 0) {
                const m = moves[Math.floor(Math.random() * moves.length)];
                board[m.to] = pieceAt(m.from);
                board[m.from] = null;
                turn = 'w';
                statusEl.textContent = "Your Turn (White)";
            } else {
                statusEl.textContent = "AI has no moves - Game Over";
            }
            drawBoard();
        }

        init();
    </script>
</body>
</html>
