<!DOCTYPE html>
<html>
<head>
<title>Archers Chess - Play Now!</title>
<style>
body { font-family: Arial, serif; text-align: center; background: #f0d9b5; color: #333; }
canvas { border: 3px solid #8b4513; cursor: pointer; background: #deb887; }
h1 { color: #8b0000; }
p { font-size: 18px; }
.light { background: #f0d9b5; }
.dark { background: #b58863; }
</style>
</head>
<body>
<h1>üèπ Archers Chess v1.0 by John Patrick Read</h1>
<p>Click your piece, then click target square. Archer validated fully. Others: no own pieces. Two-player hotseat. Your turn: <span id="turn">White</span></p>
<canvas id="board" width="600" height="480"></canvas> <!-- 60px/sq for 10x8 -->
<p>Files: ‚ÄìA A B C D E F G H H+ | Reload to restart</p>
<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const SQ = 60;
const FILES = 10;
const RANKS = 8;
const pieceFont = 'bold 40px serif';
const turnEl = document.getElementById('turn');

let board = new Array(FILES * RANKS).fill(null);
let selected = -1;
let turn = 'w'; // w white, b black

const pieces = {
  'P': '‚ôô', 'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî', 'A': 'üèπ',
  'p': '‚ôü', 'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'a': 'üèπ'
}; // Archer üèπ both (flip color if needed)

function fileName(f) { return ['‚ÄìA','A','B','C','D','E','F','G','H','H+'][f]; }

function init() {
  // Clear
  board.fill(null);
  // White rank1 (rank0 array): A R N B Q K B N R A
  board[0*RANKS + 0] = 'A'; board[1*RANKS + 0] = 'R'; board[2*RANKS + 0] = 'N';
  board[3*RANKS + 0] = 'B'; board[4*RANKS + 0] = 'Q'; board[5*RANKS + 0] = 'K';
  board[6*RANKS + 0] = 'B'; board[7*RANKS + 0] = 'N'; board[8*RANKS + 0] = 'R'; board[9*RANKS + 0] = 'A';
  // Pawns rank2 (rank1)
  for (let f=0; f<FILES; f++) board[f*RANKS + 1] = 'P';
  // Black pawns rank7 (rank6)
  for (let f=0; f<FILES; f++) board[f*RANKS + 6] = 'p';
  // Black back rank8 (rank7)
  board[0*RANKS + 7] = 'a'; board[1*RANKS + 7] = 'r'; board[2*RANKS + 7] = 'n';
  board[3*RANKS + 7] = 'b'; board[4*RANKS + 7] = 'q'; board[5*RANKS + 7] = 'k';
  board[6*RANKS + 7] = 'b'; board[7*RANKS + 7] = 'n'; board[8*RANKS + 7] = 'r'; board[9*RANKS + 7] = 'a';
  selected = -1;
  turn = 'w';
  draw();
}

function sq(file, rank) { return file * RANKS + rank; } // rank 0=1 bottom white view
function fileSq(sq) { return sq / RANKS | 0; }
function rankSq(sq) { return sq % RANKS; }

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for (let rank=7; rank>=0; rank--) { // top rank8 to bottom rank1
    for (let file=0; file<FILES; file++) {
      let x = file * SQ;
      let y = (7 - rank) * SQ;
      ctx.fillStyle = ((file + rank) % 2 === 0) ? '#f0d9b5' : '#b58863';
      ctx.fillRect(x, y, SQ, SQ);
      ctx.strokeRect(x, y, SQ, SQ);
      let bsq = sq(file, rank);
      let p = board[bsq];
      if (p) {
        ctx.fillStyle = p.toLowerCase() === p ? '#000' : '#fff'; // black dark, white light
        ctx.font = pieceFont;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(pieces[p], x + SQ/2, y + SQ/2);
      }
      // Selected highlight
      if (bsq === selected) {
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 4;
        ctx.strokeRect(x, y, SQ, SQ);
      }
    }
  }
  turnEl.textContent = turn === 'w' ? 'White' : 'Black';
}

function getSq(e) {
  let rect = canvas.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;
  let file = Math.floor(x / SQ);
  let rank = 7 - Math.floor(y / SQ);
  if (file >=0 && file < FILES && rank >=0 && rank < RANKS) return sq(file, rank);
  return -1;
}

function isWhite(p) { return p === p.toUpperCase(); }
function sameColor(p1, p2) { return isWhite(p1) === isWhite(p2); }

function archerLegal(start, target, occupied) {
  let sf = fileSq(start), sr = rankSq(start);
  let tf = fileSq(target), tr = rankSq(target);
  let dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
  for (let [dx, dy] of dirs) {
    // Check outward path
    let ok = true;
    let cf = sf + dx, cr = sr + dy;
    if (! (0<=cf && cf<FILES && 0<=cr && cr<RANKS)) ok = false;
    else if ((dx===0 || dy===0) && sq(cf,cr) in occupied) ok = false;
    if (!ok) continue;
    cf += dx; cr += dy;
    if (! (0<=cf && cf<FILES && 0<=cr && cr<RANKS)) ok = false;
    else if ((dx===0 || dy===0) && sq(cf,cr) in occupied) ok = false;
    if (!ok) continue;
    cf += dx; cr += dy;
    if (! (0<=cf && cf<FILES && 0<=cr && cr<RANKS)) continue;
    if ((dx===0 || dy===0) && sq(cf,cr) in occupied) continue;
    // end cf cr
    // left return
    let rx = -dx - dy, ry = -dy + dx;
    let sx = 0, sy = 0;
    if (Math.abs(rx) > 1) sx = rx > 0 ? 1 : -1;
    if (Math.abs(ry) > 1) sy = ry > 0 ? 1 : -1;
    if (Math.abs(rx) === 1 && Math.abs(ry) === 1) { sx = rx > 0 ? 1 : -1; sy = ry > 0 ? 1 : -1; }
    let rf = cf + sx, rr = cr + sy;
    if (rf === tf && rr === tr && 0<=rf && rf<FILES && 0<=rr && rr < RANKS) return true;
    // right
    rx = -dx + dy; ry = -dy - dx;
    sx = 0; sy = 0;
    if (Math.abs(rx) > 1) sx = rx > 0 ? 1 : -1;
    if (Math.abs(ry) > 1) sy = ry > 0 ? 1 : -1;
    if (Math.abs(rx) === 1 && Math.abs(ry) === 1) { sx = rx > 0 ? 1 : -1; sy = ry > 0 ? 1 : -1; }
    rf = cf + sx; rr = cr + sy;
    if (rf === tf && rr === tr && 0<=rf && rf<FILES && 0<=rr && rr < RANKS) return true;
  }
  return false;
}

canvas.addEventListener('click', (e) => {
  let sq = getSq(e);
  if (sq === -1) return;
  let p = board[sq];
  if (selected === -1) {
    if (p && isWhite(p) === (turn === 'w')) {
      selected = sq;
      draw();
    }
  } else {
    let sp = board[selected];
    if (sq === selected) { selected = -1; draw(); return; }
    let tp = board[sq];
    let legal = false;
    let occupied = {};
    for (let i=0; i<board.length; i++) if (board[i]) occupied[i] = true;
    if (sp[0] === 'A' || sp[0] === 'a') {
      legal = archerLegal(selected, sq, occupied);
    } else {
      // Simple for others: no own capture, for demo
      legal = !tp || !sameColor(sp, tp);
    }
    if (legal && (!tp || !sameColor(sp, tp))) {
      board[sq] = sp;
      board[selected] = null;
      turn = turn === 'w' ? 'b' : 'w';
    }
    selected = -1;
    draw();
  }
});

init();
</script>
</body>
</html>